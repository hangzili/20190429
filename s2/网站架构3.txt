


1、大型网站的特点：
   
    （1） 高并发、大流量

    （2）高可用 
   		【 可以不间断的提供服务 】

   		单点故障：
   			在架构中只有一个节点的服务或者是服务器，
   			如果这个节点出现问题，会导致整个系统不可用
   			这种现象就叫做单点故障
 
    （3）海量数据
 
    （4）用户分布广泛、网络情况复杂

   	（5）安全环境恶劣 

   	（6）需求快速biang、发布频繁

   	（7）渐进式发展 【 从小的网站发展成大的网站的 】

集群：
	很多台服务器做同样的事情。
分布式：
	整个任务分成3块，每一块单独的服务器去处理

网站的集群：
	有多台服务去处理同样的任务
网站的分布式：
	把任务分配成很多个，每个服务器去处理其中的一部分



网站发展演化历程：
	
	（1）单台服务器，部署LNMP环境 ，web服务器、PHP、mysql都放在这一台服务器

			云服务器 + 外网ip + 域名 + 部署代码

	（2）应用服务器和 数据库服务分离、文件服务【素材相关的 css js 视频 图片 等等】
			web服务器： 需要CPU和内存
			MYSQL ： 内存和磁盘的检索速度
			文件服务器： 带宽 和 硬盘的存储空间

			web服务器 和 Mysql 分成单独的服务器

			文件服务也单独一台服务器

			从一台服务器变成三台服务器

	（3）使用缓存改善网站的性能

			数据库读取数据比较慢，考虑使用缓存加快数据的访问速度

			网站数据访问的特点：
				80%的数据访问集中在20%的数据上。

			如果把这个20%的数据缓存起来，就可以加快我们的访问速度。

		 网站的内存缓存：【 redis  memcache 】
		 	1、缓存在web服务器上的本地缓存
		 		在web服务器上 装一个redis
		 		优点：
		 			缓存的数据和web服务器使用一台，直接从这台服务器找就可以
		 		缺点：
		 			内存是有限的。
		 			会发生抢占内存的情况。

		 	2、使用单独的服务器提供缓存服务
		 		使用单独的服务器安装redis 提供服务

		 		优点：
		 			内存的限制就没有了，因为可以通过多台服务器解决内存限制问题
		 		缺点：
		 			相对于本地缓存，查询稍慢。



	  # 因为加了缓存，数据库访问变快了，但是web服务器能够处理的并发是有限制的。
	 （4）通过应用服务器的集群去解决网站的并发 
	 	负载均衡的方式去解决web访问压力过大的问题
	 	【解决单台web服务器并发处理能力有限的问题】
	 			高并发2中处理方式：
	 				垂直扩展： 提高单台服务器的配置，不建议使用，因为单台服务器的处理能力是有上限的。

	 				水平扩展：通过新的服务器，去分担之前服务器的压力，建议这种方式，因为加一台可以解决的问题，后期我们可以通过持续的添加服务器，解决我们的并发问题。


	 （5）数据的主从和读写分离
	 	应用服务器集群之后，应用服务器不在成为瓶颈。虽然有redis，但是还是有部分请求会请求到数据库，我们的数据库会因为压力过大，导致访问变慢，升级宕机。

	 	通过MYSQL的主从复制，分散了查询的压力，如果主从之后访问量还是很大，我们可以搭建一主多从。


	 （6）使用反向代理和CDN加速网站相应。

	 	反向代理【Nginx搭建反向代理，用户访问的时候，去访问反向代理的服务器，通过反向代理的服务器去访问web集群】

	 	CDN加速：内容加速网络

	 	CDN部署在网络提供商的机房，用户访问的时候，会找到自己最近的网络提供商是机房去访问，这样的话，就可以加快网站是访问速度。


	 	优点：让用户尽快的访问到我们要访问的资源，加速用户的相应速度。

	 （7）分布式文件系统和分布式数据库

	 	整个系统做分库。分表，
	 	在MYSQL中用的更多的是分库、分表

	 （8）使用NOSQL和搜索引擎
	 		NOSQL ： redis   mongodb Es
	 		搜索引擎：  xunsearch   elastic search  sphinx  solr lucene

	 （9）业务拆分  【 大型网站架构最终一个解决方案 】

	 		把我们一个大的系统，拆分成多个小的系统。每个小的系统都是单独的模块。归于不同部门，有不同的人开发。

	  (10) 分布式服务 【 面向服务、微服务 】

	  		把系统拆分成很多小的模块，每个模块都提供出对应的接口
	  		模块与模块交互使用接口的方式，

优化的方式：
	1台服务器变成多台服务器
	加内存缓存（redis memcache ）
	加服务器。说白了就是通过集群的方式去解决这些问题。
		web服务器集群
		数据库服务器集群
	cdn 反向代理
	分布式解决
	业务拆分
	分布式服务器 【 把系统拆分成小的模块去做 】 



##################### 项目历程 #####################

第一版： 实现功能，只做一个终端  PC

	不要求任何架构，只需要把功能实现出来。

	如果公司没有技术，找外包公司去做。

第二版： 
	
	pc做完之后，需要做App 
	做公众号、小程序

	公司会遇到的问题：
		找外包做，或者做功能迭代，外包要的钱比较多
		而且外包公司做的东西，质量比较低


	一般情况下，公司会考虑自己成立技术部，去完善这些功能。

##################### 技术团队成立 #####################
	
	1、维护之前外包写的项目

	2、开发新的功能 【 app 小程序 公众号等 】

遇到的问题：
	外包写的代码特别烂，根本没有办法维护。

##################### 推翻原有项目重做 #####################

	1、外包写的东西维护成本比较高。

	2、在原来技术上加系你的功能比较困难


##################### 如何重做 #####################


	1、数据保留

	2、代码重写

	3、把之前的外包写的业务重新写一遍


##################### 后期项目需要开发app 公众号 #####################


	1、需要开发API接口。

	2、API接口的逻辑和之前PC的逻辑很相似。

	3、需要考虑把整个系统做拆分

	4、做成独立的接口

	5、之前PC直接调用数据库，但是现在重新做了接口，为了保证数据一致，PC和app都去掉一套接口

##################### 访问大的时候 #####################
##################### 面向服务架构 #####################
	电商会拆分成：
		用户服务
		订单服务
		商品服务
		仓库服务
		物流服务
		支付服务
		基础服务


	1、把整个系统拆分成多个小的模块

	2、每个组负责一个小的模块

	3、各个模块直接通过接口交互。

	4、服务和服务直接通过接口通讯

	6、后期如果服务的访问压力过大，考虑使用集群的方式解决【多台服务器解决访问压力】

########################################################################################################################

大型网站架构模式：
	
	1、分层：  【面向服务架构】

		应用层 ： 用户看到的页面			【用户看到的页面】
		服务层 ： 为应用层提供服务支持    【API的接口】
		数据层 ： 为服务层提供数据支持	【mysql redis】


		调用方式是：
			应用层  -> 服务层  -> 数据层

		（1）不允许跨层调用
		（2）不允许逆向调用
		（3）只能 应用层  -> 服务层  -> 数据层


	2、分割

		把整个系统分割成多个模块，每个模块按照功能可以继续分割。

		【比如说： www.jd.com  list.jd.com  item.jhd.com  shouji.jd.com 】

		大公司需要的是螺丝钉    【 每个人只负责项目其中一部分功能 】
		小公司需要的是全能人才  【 小公司需要的是一个人可以吧所有事情搞定 】


	3、分布式

		把不同的模块部署在不同的服务器上
			问题：
				1、调用接口必须使用网络，可能会影响访问速度
				2、服务器越多，宕机的可能性越大
				3、一个服务宕机可能会导致整个系统不可用
				4、业务的正确性难以保证

	4、集群 
			（1）集群可以解决并发问题，多台服务器处理能力比一台更好
			（2）每个模块都至少部署2个节点。挂掉一个之后还有一台可以使用，可以保证网站的高可用


	5、缓存

		CDN：加速静态资源的访问
		反向代理缓存： 省去去web集群访问的时间
		本地缓存： 浏览器的缓存
		内存缓存： 分布式缓存，【redis，memcache】 ，加快数据的访问速度

	6、异步

		耦合：  一件事情依赖另外一件事情

		正常：
			创建订单 商品减库存

		改一下：
			创建订单   ->  队列  a-2库存 b-1库存
			商品-> 取 队列的数据  -> 去减商品的库存

		可能与遇到的问题:
			最后一件商品：一个用户买了这个商品，写入队列了， 队列还没有来得及处理，另外一个用户又买了这个商品。

		解决：
			（1）能异步就异步，不能异步就同步

			（2）库存多的情况下，走异步，少的情况下，走同步

	7、冗余  【多余的】【影子服务】

		部署服务和网站的时候，最好使用多个服务器组成集群，防止出现一台服务器当即导致系统不可用

	8、自动化

		自动化部署
		自动化降级
		自动化运维
		自动化监控
		自动化报警

	9、安全
		SQL注入
		XSS
		CSRF
		Ddos


关于优化：
	前端优化：

	1、浏览器访问优化

		1、减少http请求

			（1）把多个css文件合并成一个css文件
			（2）合并js的问题
			（3）合并图片 【雪碧图】
					雪碧图： 把多个图标放在同一个图片上，展示的时候通过css的背景位置展示对应的图标

		2、压缩文件 [把文件中的空格去掉]
			jquery.js  jquery.min.js 

		3、使用浏览器的缓存  
			解决浏览器缓存，导致样式不生效的办法【 在静态文件后加上版本号 】
			a.js?v=1.0.0
			a.js?v=1.0.1

		4、css放上边 js 放下边

			css加载完成之后开始渲染页面，js加载之后立马执行，而且js是单线程加载的，会阻塞整个请求。

		5、减少cookie的传输
			因为cookie每次回跟着http请求的header头信息，带到服务端，如果cookie中存在的数据比较多，可能会导致请求变慢

	2、使用CDN加速访问

	3、使用反向代理



	应用服务器的优化：

		1、缓存

		2、合理使用缓存

			不需要缓存的数据：
				频繁修改的数据不需要缓存，读写比例 2：1 这样的数据才需要缓存

			不是热点数据不需要缓存
		3、异步

		4、集群

		5、代码优化


优化 ： 
前段优化：
1、减少http请求  css合并 js合并
2、压缩css、js文件
3、使用浏览器端的缓存
4、雪碧图 --- 多个小图标合并到一个图片里边，通过css的背景位置，找到需要的图标  --- 只需要加载一次即可
5、懒加载  --- 只加载看到的第一屏，下拉的时候继续加载。
6、预加载 ---  展示图片的时候，先显示一张默认图。等加载完成之后，去加载对应的图片。
7、避免空的src 
8、避免css样式表达式
9、cdn加速   --- 内容加速网络



php优化：
1、用单引号代替双引号，双引号会查找变量
2、避免使用require_once require_once会判断文件是否加载过
3、使用静态方法代替普通方法 静态方法速度比普通方法快4倍
4、变量使用完成之后需要销毁
5、尽量不要使用 @ 
6、include用绝对路径 不要使用相对路径 ，相对路径会有查找的过程
7、避免使用 __SET __GET __AUTOLOAD 
8、循环的时候 先确定循环次数，不要每次循环都要计算
9、避免循环查库 
10、避免多层foreach嵌套



MYSQL优化：
1、查询优化  能单表的单表
2、查询一条数据使用limit 1   ---  
3、生成查询缓存
4、使用索引
5、多表查询使用id进行关联 == 小表连接大表   
6、数据库分表
7、数据库分区
8、数据库集群
9、要查询的字段避免使用*号，指定需要的字段
10、避免使用%前缀的模糊查询
11、避免使用负向查询
12、避免使用or查询
13、避免使用子查询
14、避免使用mysql自带函数
15、不要使用rand()
16、有顺序的读取
17、设置合适的数据类型
18、避免使用text类型
19、避免使用null




公司的环境分为：

	开发环境 ： 开发工程师开发代码的环境

	测试环境 ： 让测试工程师测试的环境

	灰度【仿真】环境 ： 和线上环境一致，但是不让用户访问，只有内部人员能够访问。

	生产【线上】环境 ： 线上的环境，就是我们项目线上运行的环境


上线流程：

	之前：
		开发环境 提交代码 到测试环境 ， 测试没有问题，把代码提交到 生产环境


	添加了灰度环境之后 【可以保证代码上线的成功率】

		公司要求：
			功能要上线，必须在灰度跑2天以上没有问题。


		开发环境 提交代码 到测试环境 ，测试没有问题之后，不直接提交生成环境，把测试环境的代码提交到 灰度环境

		因为灰度环境和线上环境一致，数据库也一样，在灰度先进行测试，如果灰度测试没有问题，再去上线。
15210966203










































