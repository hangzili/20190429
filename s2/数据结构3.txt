1、什么是数据结构？
	
	数据是用来研究数据的存储方式。

2、存储空间：
	内存

3、数据结构；有哪些？
	线性表
	树结构
	图存储


4、线性表：
	
	线性表：存储数据是依次排列的，而且只有一个前驱元素和后驱元素，这种存储结构叫做线性表


5、线性表存储方式分为：
	顺序存储结构和链式存储结构

	顺序存储(顺序表)：【缺点：对空间的顺序有要求，顺序存储的时候，必须要求是连续的空间】
		所有的数据，是挨着进行存储的（物理地址是紧挨的）。

	链式存储（链表）： 【优点：链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的】

		由于存储的位置不是连续的，所以通过指针确定数据的顺序。



6、物理地址：
	数据的实际存储地址。就是说这个数据存储在内存的那个地方。


7、特殊的线性表：	栈 和 队列

	栈：【比如说现在有一个箱子：箱子里边是一层一层的，给箱子放东西，如果现在想拿到箱子最下边的东西，必须把上边的箱子全部拿开才行】

	栈对数据进出的要求是：
		先进后出，后进先出

	队列：【相当于排队的概念，先排队的人先处理，后进入队列的后处理】
		只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列

8、树存储结构：
	
	数据存在一对多的关系，使用树存储结构

9、图存储结构：
	
	数据存在多对多的关系，可以使用图存储结构


10、数据结构：
	
	线性表：
		顺序存储结构： 顺序表
		链式存储架构： 链表
						单链表、循环链表、双链表、栈、队列
	树结构：
		二叉树

	图结构：

11、算法，即解决问题的方法。
同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。

12、算法是解决某个问题的想法、思路；

	程序是在心中有算法的前提下编写出来的可以运行的代码。

	算法相当于是程序的雏形



13、好算法衡量标准:

	首先它必须能够解决这个问题（称为准确性）。
	通过这个算法编写的程序要求在任何情况下不能崩溃（称为健壮性）。

	时间复杂度：算法的运行时间
	空间复杂度：运行算法所需的内存空间大小

	在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”

14、时间复杂度： 【估算出来的】
		
		循环结构中代码循环的次数
		代码中的循环次数

	空间复杂度：

		代码运行需要占用的内存空间


	a) ++x; s=0;

	b) for (int i=1; i<=n; i++) {
		 ++x; s+=x; 
		}
	c) for (int i=1; i<=n; i++) { 
			for (int j=1; i<=n; j++) { 
				++x; s+=x; 
			} 
		}




15、时间复杂度表示方式：
	O(频度)

	a = O(1);
	b = O(n)
	c = O(n²)

	如果a、b、c组成一段程序，那么算法的时间复杂度为O(n²+n+1)。但这么表示是不对的，还需要对n²+n+1进行简化。

	简化的过程总结为3步：
	（1）去掉运行时间中的所有加法常数。（例如 n²+n+1，直接变为 n²+n）
	（2）只保留最高项。（n²+n 变成 n²）
	（3）如果最高项存在但是系数不是1，去掉系数。（n²系数为 1）

	所以，最终a、b和c合并而成的代码的时间复杂度为O(n²)。


16、常见的时间复杂度：

	O(1)常数阶 < O(log n)对数阶 < O(n)线性阶 < O(n²)平方阶 < O(n³)(立方阶) < O(2的n次方) (指数阶)

17、空间复杂度：
	
	指的是算法运行的过程中需要占用的内存

		$a = 1; 0(1)
		for( i =1;i<100;i++ ){
			arr[] = i;
		}		
	空间复杂度计算方式参考时间复杂度，主要评估的是 占用空间的大小。


	算法的时间复杂度和空间复杂度是可以相互转化的。 【如果现在内存有限制，可以用时间换空间，如果时间有要求，就可以拿空间换时间】


18、逻辑结构和存储结构
	
	逻辑顺序： 数据之间的逻辑关系
	存储结构： 物理存储地址，在内存中如何存储这些数据的 【数据在物理存储空间上选择集中存放还是分散存放 】
	【物理结构】

19、数据结构和算法的关系区别？
	
	数据结构： 负责数据的存储，选择合适的数据类型将数据存储起来，

	算法：通过分析数据，得到最终答案

	数据结构用于解决数据存储问题，而算法用于处理和分析数据，它们是完全不同的两类学科

20、线性表：

	全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。

	将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。

20、顺序存储结构和链式存储结构  【 区别： 存储的方式不同，顺序存储是存放在连续的空间上 链式存储: 数据可能不实在连续的空间 】

		所有的数据，是挨着进行存储的（物理地址是紧挨的）。

	链式存储（链表）： 【优点：链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的】

		由于存储的位置不是连续的，所以通过指针确定数据的顺序。

21、前驱和后继
	
	直接前驱元素： 左侧紧挨着的元素，叫做直接前驱元素
	前驱元素：	所有在当前数字左边的元素，都叫做前驱元素
		前驱元素可能有很多，直接前驱只有一个
	1 2  3 【4】 5

	直接后继元素： 右边紧挨着的元素，叫做直接后继元素
	后继元素：	所有在当前数字右边的元素，都叫做后继元素
		后继元素可能有很多，直接后继只有一个

22： 顺序表存储数据的要求：
	顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。



23、 顺序表：

		是一种线性存储结构，他的数据存储是存储连续的物理空间上。

		要求：
			顺序表存储数据的时候，必须提前申请连续的物理空间【内存】，如果使用线性表存储一个G的数据，必须声明一个G的连续空间，如果现在
			没有1个G的连续空间，则顺序存储是没法使用。

	 顺序表的基本操作：

	 	 顺序表插入的过程：
	 	 	1、遍历顺序表，找到数据要插入的节点
	 	 	2、把节点之后的元素，全部往后挪一位
	 	 	3、要插入的元素写入对应的位置接口

	 	 删除：
	 	 	1、遍历顺序表，找到要删除的元素
	 	 	2、把元素删除
	 	 	3、把后边所有的元素 往前边移动

	 	 查找：
	 	 	1、遍历顺序表
	 	 	2、找到对应的元素

	 	 更改：
	 	 	1、遍历顺序表，找到对应的元素
	 	 	2、把元素修改成新值

24、 链表
	链表，别名链式存储结构或单链表

	也是一种线性存储结构，他的数据不需要存储在连续的空间上。

	链表存储的数据的时候，因为数据不再连续的空间上，为了解决数据的对应关系，在存储数据的时候，
	不仅存储数据的值，而且还给这个数据加了指针，指向他的下一个元素。


	存储结构：
		数据和指针。


	链表中的头结点：
		不存任何数据的节点，在数据的第一个节点

	首元节点： [链表中存储的第一个数据节点]
		链表中称第一个存有数据的节点为首元节点

	链表的基本操作：

		插入元素：	
			1、遍历链表，找到数据要插入的位置
			2、把链表断开，把直接前驱元素的指针修改为空
			3、加入新的元素
			4、把直接前驱元素的指针 执行 新加入的元素
			5、新加入的元素 指针指向指向之前的 节点

		删除元素：
			1、遍历链表，找到要删除的元素
			2、把 删除元素的 直接前驱元素 断开
			3、把直接前驱元素 指向 删除元素的 直接后继元素

		修改元素：
			1、遍历链表，找到要查找的元素

		更新元素：
			1、遍历链表，找到要修改的元素
			2、修改元素的 数据 即可

25、 顺序表和链表的区别：
	
	内存声明说明：
		顺序表：
			一次开辟，永久使用，长度一般都是固定的
		链表：
			使用的时候，只开辟能够存储这一个数据的空间即可
			如果需要继续存储数据，可以继续开辟新的空间

	空间使用：

		顺序表：
			顺序表的空间利用率显然要比链表高
		链表：
			每次只申请一个节点的空间，且空间的位置是随机的，
			空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间
	时间复杂度：
		
		如果数据很少做插入、删除、修改的时候 ，访问比较多  使用顺序表
			顺序表 访问元素的时间复杂度为 O(1)
			顺序表插入元素 ，需要移动大量的元素，删除、修改、插入 时间复杂度 是 O(n)


		如果涉及到插入、删除、修改非常多，访问很少        建议使用 链表
			链表 访问访问元素 时间复杂度是 O(n)
			链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；

26、静态链表，也是线性存储结构的一种，它兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。




27、单向链表(单链表)：每个数据节点中都有数据和指针，指针指向他的直接后继元素（指向下一个数据节点）

    双向链表：每个数据节点都有数据和指针， 指针分为2个，一个指针指向他的直接后继元素（指向下一个数据节点）另外一个指针指向他的直接前驱元素（ 指向前一个数据节点 ）


    单链表：【1 => 2】            【2 =>3】      【3 =>null】  
	双链表：  【null <= 1 =>2】   【1<= 2 =>3】  【2<= 3 => null】 

28、双链表的基本操作：
	
	插入元素：	
			1、遍历链表，找到数据要插入的位置
			2、把链表断开，把直接前驱元素的指针修改为空
			3、加入新的元素
			4、把直接前驱元素的指针 执行 新加入的元素
			5、把 新插入的数据的 直接后继元素的直接直接前驱元素 修改为新插入的数据节点

		删除元素：
			1、遍历链表，找到要删除的元素
			2、把 删除元素的 直接前驱元素 断开
			3、把直接前驱元素 指向 删除元素的 直接后继元素
			4、找到 删除元素的后继元素  
			5、把找到的节点 他的直接前驱元素 指向 被删除节点 之前的元素

		查找元素：
			1、遍历链表，找到要查找的元素

		更新元素：
			1、遍历链表，找到要修改的元素
			2、修改元素的 数据 即可

29、循环链表：

	循环单链表：	
		链表中的最后一个元素指向 链表中的第一个元素
	循环双链表：
		链表中的最后一个元素指向 链表中的第一个元素，链表中的第一个元素指向最后元素

	单链表： 【1 => 2】            【2 =>3】      【3 =>null】  
	循环单链表： 【1 => 2】            【2 =>3】      【3 => 1】  
	双链表：  【null <= 1 =>2】   【1<= 2 =>3】  【2<= 3 => null】 
	循环双链表：【3 <= 1 =>2】   【1<= 2 =>3】  【2<= 3 => 1 】 






面试问题：
	先有思路还是先有代码？
	   先有思路，根据思路写代码

	为什么需要有工作经验的人？
		有工作经验的人，考虑的问题更全面。

	登录需要做多久？
		需要先了解具体的需求，然后在给出具体的时间





































